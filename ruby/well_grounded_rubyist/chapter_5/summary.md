#### Summary

Точки с запятой всегда можно использовать для имитации разрывов строк:  
```if x > 10; puts x; end```
___
```
if false
  x = 1
end
p x # -> nil
p y # -> NameError: undefined local variable or method 'y'
```
___
Будет предупреждение: warning: found = in conditional, should be ==
```
if x = 1
  puts "Привет!"
end
```
___
иногда удобно выполнить присваивание и проверку одновременно, 
особенно когда вы используете метод, который возвращает nil 
в случае неудачи и какое-то значение в случае успеха
```
name = "David A. Black"
if m = /a/.match(name)
  puts "Совпадение найдено!"
  print "Вот начало строки без совпадения: "
  puts m.pre_match
  print "Вот конец строки без совпадения: "
  puts m.post_match
else
  puts "Совпадений нет"
end
```
___
Для строк и, действительно, для любого объекта, 
который его не переопределяет, === работает так же, как == (базовый метод для проверки равенства строк). 
Но другие классы могут определить проверку равенства совершенно другим способом.

___
next переход к след. итерации цикла

___
```
n = 1
begin
  puts n
  n = n + 1
end while n < 11
puts "Готово!"
```

___
```
if (a, b = [3, 4])
  puts a
  puts b
end
```
-> warning: found `= literal' in conditional, should be ==

___
Итератор — это метод в Ruby, который имеет дополнительный элемент 
в синтаксисе вызова: он ожидает, что вы предоставите ему блок кода. 

___
Сам loop написан на C (и использует функцию на C, чтобы добиться того же эффекта, что и yield)

___
Если вы научитесь думать о блоке кода как о синтаксическом элементе вызова метода, а не как об одном из аргументов, 
вам будет легче понимать различные вариации базовой темы итерации.

___
Метод map проходит по массиву элемент за элементом, 
вызывая блок кода один раз для каждого элемента и создавая новый массив, 
состоящий из результатов всех этих вызовов блока. 

___

```
puts(array.map)
```
-> Enumerator
___

Поведение times хорошо иллюстрирует тот факт, 
что передача управления блоку и возврат из метода — это две разные вещи.

___

```
def args_unleashed(a, b=1, *c, d, e)
  puts "Аргументы:"
  p a, b, c, d, e
end

def block_args_unleashed
  yield(1, 2, 3, 4, 5)
end

block_args_unleashed do |a, b=1, *c, d, e|
  puts "Аргументы:"
  p a, b, c, d, e
end
```
___

блоки имеют прямой доступ к переменным, которые уже существуют. 
Однако параметры блока (переменные, заключенные между вертикальными чертами) 
ведут себя иначе, чем обычные переменные. 
Если у вас есть переменная с определенным именем в области видимости 
и вы также используете это имя как одно из параметров блока, 
тогда эти две переменные — та, которая уже существует, 
и та, которая в списке параметров, — не одно и то же.
___

Создание исключения (raising an exception) означает остановку 
нормального выполнения программы и последующую обработку возникшей 
проблемы или выход из программы.
___
```
open_user_file do |filename|
  fh = File.open(filename)
  yield fh
  fh.close
rescue
  puts "Couldn't open your file!"
end
```
___
Вы можете использовать rescue для перехвата практически всех исключений. 
Но рекомендуется указывать конкретные исключения, а не использовать общий перехват.
___
Объект исключения, как и любой объект, поддерживает методы. 
Особенно полезны методы backtrace и message:
backtrace возвращает массив строк, представляющих стек вызовов 
в момент возникновения исключения: имена методов, файлы и номера строк.
message возвращает строку с сообщением, переданным в raise.
___
ensure

Дополнительным инструментом управления является блок ensure, 
который выполняется безусловно, независимо от того, возникло исключение или нет.
___

#### Вопросы для самопроверки:
1. Что такое control-flow techniques? И что к ним относиться?
Ответ: Это набор правил и конструкций программирования, 
которые опр. порядок выполнения. 
К ним относяться: условия, циклы, итерация, исключения.
2. В чем отличие циклов от итераций?
Ответ:
3. Почему исключения тоже относяться к control-flow techniques?
Ответ:
